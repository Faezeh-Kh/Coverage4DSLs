/**
 * generated by Xtext 2.10.0
 */
package org.imt.xminijava.xtext.validation;

import com.google.common.base.Objects;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.Iterables;
import com.google.inject.Inject;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.imt.minijava.xminiJava.AccessLevel;
import org.imt.minijava.xminiJava.Block;
import org.imt.minijava.xminiJava.ClassRef;
import org.imt.minijava.xminiJava.Expression;
import org.imt.minijava.xminiJava.Field;
import org.imt.minijava.xminiJava.FieldAccess;
import org.imt.minijava.xminiJava.Interface;
import org.imt.minijava.xminiJava.Member;
import org.imt.minijava.xminiJava.Method;
import org.imt.minijava.xminiJava.MethodCall;
import org.imt.minijava.xminiJava.NamedElement;
import org.imt.minijava.xminiJava.NewObject;
import org.imt.minijava.xminiJava.Parameter;
import org.imt.minijava.xminiJava.Program;
import org.imt.minijava.xminiJava.Return;
import org.imt.minijava.xminiJava.Statement;
import org.imt.minijava.xminiJava.Super;
import org.imt.minijava.xminiJava.TypeDeclaration;
import org.imt.minijava.xminiJava.TypeRef;
import org.imt.minijava.xminiJava.VariableDeclaration;
import org.imt.minijava.xminiJava.XminiJavaPackage;
import org.imt.xminijava.xtext.XMiniJavaModelUtil;
import org.imt.xminijava.xtext.scoping.XMiniJavaIndex;
import org.imt.xminijava.xtext.typing.XMiniJavaTypeComputer;
import org.imt.xminijava.xtext.typing.XMiniJavaTypeConformance;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class XMiniJavaValidator extends AbstractXMiniJavaValidator {
  protected static final String ISSUE_CODE_PREFIX = "org.tetrabox.minijava.xtext.";
  
  public static final String HIERARCHY_CYCLE = (XMiniJavaValidator.ISSUE_CODE_PREFIX + "HierarchyCycle");
  
  public static final String FIELD_SELECTION_ON_METHOD = (XMiniJavaValidator.ISSUE_CODE_PREFIX + "FieldSelectionOnMethod");
  
  public static final String METHOD_INVOCATION_ON_FIELD = (XMiniJavaValidator.ISSUE_CODE_PREFIX + "MethodInvocationOnField");
  
  public static final String UNREACHABLE_CODE = (XMiniJavaValidator.ISSUE_CODE_PREFIX + "UnreachableCode");
  
  public static final String MISSING_FINAL_RETURN = (XMiniJavaValidator.ISSUE_CODE_PREFIX + "MissingFinalReturn");
  
  public static final String EXTRA_FINAL_RETURN = (XMiniJavaValidator.ISSUE_CODE_PREFIX + "ExtraFinalReturn");
  
  public static final String DUPLICATE_ELEMENT = (XMiniJavaValidator.ISSUE_CODE_PREFIX + "DuplicateElement");
  
  public static final String INCOMPATIBLE_TYPES = (XMiniJavaValidator.ISSUE_CODE_PREFIX + "IncompatibleTypes");
  
  public static final String INVALID_ARGS = (XMiniJavaValidator.ISSUE_CODE_PREFIX + "InvalidArgs");
  
  public static final String WRONG_METHOD_OVERRIDE = (XMiniJavaValidator.ISSUE_CODE_PREFIX + "WrongMethodOverride");
  
  public static final String MEMBER_NOT_ACCESSIBLE = (XMiniJavaValidator.ISSUE_CODE_PREFIX + "MemberNotAccessible");
  
  public static final String DUPLICATE_CLASS = (XMiniJavaValidator.ISSUE_CODE_PREFIX + "DuplicateClass");
  
  public static final String WRONG_SUPER_USAGE = (XMiniJavaValidator.ISSUE_CODE_PREFIX + "WrongSuperUsage");
  
  public static final String REDUCED_ACCESSIBILITY = (XMiniJavaValidator.ISSUE_CODE_PREFIX + "ReducedAccessibility");
  
  public static final String ABSTRACT_METHOD_BODY = (XMiniJavaValidator.ISSUE_CODE_PREFIX + "AbstractMethodBody");
  
  public static final String ABSTRACT_METHOD_CLASS = (XMiniJavaValidator.ISSUE_CODE_PREFIX + "AbstractMethodClass");
  
  public static final String CONSTRUCTOR_CLASS = (XMiniJavaValidator.ISSUE_CODE_PREFIX + "ConstructorClass");
  
  public static final String CONSTRUCTOR_ABSTRACT = (XMiniJavaValidator.ISSUE_CODE_PREFIX + "ConstructorAbstract");
  
  public static final String INTERFACE_MEMBERS = (XMiniJavaValidator.ISSUE_CODE_PREFIX + "InterfaceMembers");
  
  public static final String INTERFACE_SUPERTYPE = (XMiniJavaValidator.ISSUE_CODE_PREFIX + "InterfaceSuperType");
  
  public static final String CLASS_SUPERTYPE = (XMiniJavaValidator.ISSUE_CODE_PREFIX + "ClassSuperType");
  
  @Inject
  @Extension
  private XMiniJavaModelUtil _xMiniJavaModelUtil;
  
  @Inject
  @Extension
  private XMiniJavaTypeComputer _xMiniJavaTypeComputer;
  
  @Inject
  @Extension
  private XMiniJavaTypeConformance _xMiniJavaTypeConformance;
  
  @Inject
  @Extension
  private XMiniJavaAccessibility _xMiniJavaAccessibility;
  
  @Inject
  @Extension
  private XMiniJavaIndex _xMiniJavaIndex;
  
  @Inject
  @Extension
  private IQualifiedNameProvider _iQualifiedNameProvider;
  
  @Check
  public void checkClassHierarchy(final TypeDeclaration c) {
    boolean _contains = this._xMiniJavaModelUtil.classHierarchy(c).contains(c);
    if (_contains) {
      String _name = c.getName();
      String _plus = ("Cycle in hierarchy of class \'" + _name);
      String _plus_1 = (_plus + "\'.");
      this.error(_plus_1, XminiJavaPackage.eINSTANCE.getNamedElement_Name(), 
        XMiniJavaValidator.HIERARCHY_CYCLE, c.getName());
    }
  }
  
  public boolean isAnImplementionOf(final Method m1, final Method m2) {
    EObject _eContainer = m1.eContainer();
    final org.imt.minijava.xminiJava.Class c = ((org.imt.minijava.xminiJava.Class) _eContainer);
    EObject _eContainer_1 = m2.eContainer();
    final TypeDeclaration t = ((TypeDeclaration) _eContainer_1);
    final boolean conforms = this._xMiniJavaTypeConformance.isConformant(c, t);
    final boolean returnConforms = this._xMiniJavaTypeConformance.isConformant(this._xMiniJavaTypeComputer.getType(m1.getTypeRef()), this._xMiniJavaTypeComputer.getType(m2.getTypeRef()));
    final Function1<Parameter, TypeRef> _function = (Parameter it) -> {
      return it.getTypeRef();
    };
    final Function1<TypeRef, TypeDeclaration> _function_1 = (TypeRef it) -> {
      return this._xMiniJavaTypeComputer.getType(it);
    };
    final List<TypeDeclaration> m1paramtypes = ListExtensions.<TypeRef, TypeDeclaration>map(ListExtensions.<Parameter, TypeRef>map(m1.getParams(), _function), _function_1);
    final Function1<Parameter, TypeRef> _function_2 = (Parameter it) -> {
      return it.getTypeRef();
    };
    final Function1<TypeRef, TypeDeclaration> _function_3 = (TypeRef it) -> {
      return this._xMiniJavaTypeComputer.getType(it);
    };
    final List<TypeDeclaration> m2paramtypes = ListExtensions.<TypeRef, TypeDeclaration>map(ListExtensions.<Parameter, TypeRef>map(m2.getParams(), _function_2), _function_3);
    return (((conforms && Objects.equal(m1.getName(), m2.getName())) && returnConforms) && IterableExtensions.elementsEqual(m1paramtypes, m2paramtypes));
  }
  
  @Check
  public void checkAllMethodsImplemented(final org.imt.minijava.xminiJava.Class c) {
    boolean _isAbstract = c.isAbstract();
    boolean _not = (!_isAbstract);
    if (_not) {
      final HashSet<Method> nonAbstract = new HashSet<Method>();
      final Function1<Method, Boolean> _function = (Method it) -> {
        boolean _isAbstract_1 = it.isAbstract();
        return Boolean.valueOf((!_isAbstract_1));
      };
      Iterables.<Method>addAll(nonAbstract, IterableExtensions.<Method>filter(this._xMiniJavaModelUtil.methods(c), _function));
      final HashSet<Method> abstract_ = new HashSet<Method>();
      final Set<TypeDeclaration> visited = CollectionLiterals.<TypeDeclaration>newLinkedHashSet();
      final Set<TypeDeclaration> current = this._xMiniJavaModelUtil.getSuperTypes(c);
      while ((!current.isEmpty())) {
        {
          final Function1<TypeDeclaration, EList<Member>> _function_1 = (TypeDeclaration it) -> {
            return it.getMembers();
          };
          final Set<Method> superTypesMethods = IterableExtensions.<Method>toSet(Iterables.<Method>filter((Iterables.<Member>concat(IterableExtensions.<TypeDeclaration, EList<Member>>map(current, _function_1))), Method.class));
          final Function1<Method, Boolean> _function_2 = (Method it) -> {
            return Boolean.valueOf((it.isAbstract() || (it.eContainer() instanceof Interface)));
          };
          final Map<Boolean, List<Method>> sorting = IterableExtensions.<Boolean, Method>groupBy(superTypesMethods, _function_2);
          Set<Method> _xifexpression = null;
          boolean _containsKey = sorting.containsKey(Boolean.valueOf(true));
          if (_containsKey) {
            _xifexpression = IterableExtensions.<Method>toSet(sorting.get(Boolean.valueOf(true)));
          } else {
            _xifexpression = Collections.<Method>unmodifiableSet(CollectionLiterals.<Method>newHashSet());
          }
          final Set<Method> superTypeAbstractMethods = _xifexpression;
          Set<Method> _xifexpression_1 = null;
          boolean _containsKey_1 = sorting.containsKey(Boolean.valueOf(false));
          if (_containsKey_1) {
            _xifexpression_1 = IterableExtensions.<Method>toSet(sorting.get(Boolean.valueOf(false)));
          } else {
            _xifexpression_1 = Collections.<Method>unmodifiableSet(CollectionLiterals.<Method>newHashSet());
          }
          final Set<Method> superTypeNonAbstractMethods = _xifexpression_1;
          nonAbstract.addAll(superTypeNonAbstractMethods);
          abstract_.addAll(superTypeAbstractMethods);
          visited.addAll(current);
          final LinkedHashSet<TypeDeclaration> copy = CollectionLiterals.<TypeDeclaration>newLinkedHashSet();
          copy.addAll(current);
          current.clear();
          final Function1<TypeDeclaration, Set<TypeDeclaration>> _function_3 = (TypeDeclaration it) -> {
            return this._xMiniJavaModelUtil.getSuperTypes(it);
          };
          final Function1<TypeDeclaration, Boolean> _function_4 = (TypeDeclaration it) -> {
            boolean _contains = visited.contains(it);
            return Boolean.valueOf((!_contains));
          };
          Iterables.<TypeDeclaration>addAll(current, IterableExtensions.<TypeDeclaration>filter(Iterables.<TypeDeclaration>concat(IterableExtensions.<TypeDeclaration, Set<TypeDeclaration>>map(copy, _function_3)), _function_4));
        }
      }
      final Function1<Method, Boolean> _function_1 = (Method a) -> {
        final Function1<Method, Boolean> _function_2 = (Method na) -> {
          return Boolean.valueOf(this.isAnImplementionOf(na, a));
        };
        boolean _exists = IterableExtensions.<Method>exists(nonAbstract, _function_2);
        return Boolean.valueOf((!_exists));
      };
      boolean _exists = IterableExtensions.<Method>exists(abstract_, _function_1);
      if (_exists) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("All abstract methods must be implemented, or the class must be made abstract.");
        this.error(_builder.toString(), c, 
          XminiJavaPackage.eINSTANCE.getClass_SuperClass(), XMiniJavaValidator.ABSTRACT_METHOD_CLASS);
      }
    }
  }
  
  @Check
  public void checkUnreachableCode(final Block block) {
    final EList<Statement> statements = block.getStatements();
    for (int i = 0; (i < (((Object[])Conversions.unwrapArray(statements, Object.class)).length - 1)); i++) {
      Statement _get = statements.get(i);
      if ((_get instanceof Return)) {
        this.error("Unreachable code", statements.get((i + 1)), null, 
          XMiniJavaValidator.UNREACHABLE_CODE);
        return;
      }
    }
  }
  
  @Check
  public void checkReturn(final Method method) {
    String _name = method.getName();
    boolean _tripleNotEquals = (_name != null);
    if (_tripleNotEquals) {
      EClass _eClass = method.getTypeRef().eClass();
      EClass _voidTypeRef = XminiJavaPackage.eINSTANCE.getVoidTypeRef();
      boolean _tripleNotEquals_1 = (_eClass != _voidTypeRef);
      if (_tripleNotEquals_1) {
        Return _returnStatement = this._xMiniJavaModelUtil.returnStatement(method);
        boolean _tripleEquals = (_returnStatement == null);
        if (_tripleEquals) {
          this.error(
            "Method must end with a return statement", 
            XminiJavaPackage.eINSTANCE.getMethod_Body(), 
            XMiniJavaValidator.MISSING_FINAL_RETURN);
        }
      } else {
        Return _returnStatement_1 = this._xMiniJavaModelUtil.returnStatement(method);
        boolean _tripleNotEquals_2 = (_returnStatement_1 != null);
        if (_tripleNotEquals_2) {
          this.error(
            "Void method must not end with a return statement", 
            XminiJavaPackage.eINSTANCE.getMethod_Body(), 
            XMiniJavaValidator.EXTRA_FINAL_RETURN);
        }
      }
    }
  }
  
  @Check
  public void checkNoDuplicateClasses(final Program p) {
    this.checkNoDuplicateElements(p.getClasses(), "class");
  }
  
  @Check
  public void checkNoDuplicateMembers(final org.imt.minijava.xminiJava.Class c) {
    this.checkNoDuplicateElements(this._xMiniJavaModelUtil.fields(c), "field");
    final Function1<Method, Boolean> _function = (Method it) -> {
      String _name = it.getName();
      return Boolean.valueOf((_name != null));
    };
    this.checkNoDuplicateElements(IterableExtensions.<Method>filter(this._xMiniJavaModelUtil.methods(c), _function), "method");
  }
  
  @Check
  public void checkNoDuplicateSymbols(final Method m) {
    this.checkNoDuplicateElements(m.getParams(), "parameter");
    this.checkNoDuplicateElements(EcoreUtil2.<VariableDeclaration>getAllContentsOfType(m.getBody(), VariableDeclaration.class), "variable");
  }
  
  @Check
  public void checkConformance(final Expression exp) {
    final TypeDeclaration actualType = this._xMiniJavaTypeComputer.typeFor(exp);
    final TypeDeclaration expectedType = this._xMiniJavaTypeComputer.expectedType(exp);
    if (((expectedType == null) || (actualType == null))) {
      return;
    }
    boolean _isConformant = this._xMiniJavaTypeConformance.isConformant(actualType, expectedType);
    boolean _not = (!_isConformant);
    if (_not) {
      String _name = expectedType.getName();
      String _plus = ("Incompatible types. Expected \'" + _name);
      String _plus_1 = (_plus + "\' but was \'");
      String _name_1 = actualType.getName();
      String _plus_2 = (_plus_1 + _name_1);
      String _plus_3 = (_plus_2 + "\'");
      this.error(_plus_3, null, 
        XMiniJavaValidator.INCOMPATIBLE_TYPES);
    }
  }
  
  @Check
  public void checkMethodInvocationArguments(final MethodCall sel) {
    final Method method = sel.getMethod();
    int _size = method.getParams().size();
    int _size_1 = sel.getArgs().size();
    boolean _notEquals = (_size != _size_1);
    if (_notEquals) {
      int _size_2 = method.getParams().size();
      String _plus = ("Invalid number of arguments: expected " + Integer.valueOf(_size_2));
      String _plus_1 = (_plus + " but was ");
      int _size_3 = sel.getArgs().size();
      String _plus_2 = (_plus_1 + Integer.valueOf(_size_3));
      this.error(_plus_2, 
        XminiJavaPackage.eINSTANCE.getMethodCall_Method(), XMiniJavaValidator.INVALID_ARGS);
    }
  }
  
  @Check
  public void checkConstructorAbstractClass(final NewObject n) {
    boolean _isAbstract = n.getType().isAbstract();
    if (_isAbstract) {
      this.error("Cannot construct an instance of an abstract class.", XminiJavaPackage.eINSTANCE.getNewObject_Type(), 
        XMiniJavaValidator.CONSTRUCTOR_ABSTRACT);
    }
  }
  
  @Check
  public void checkMethodOverride(final org.imt.minijava.xminiJava.Class c) {
    final Map<String, Method> hierarchyMethods = this._xMiniJavaModelUtil.classHierarchyMethods(c);
    Iterable<Method> _methods = this._xMiniJavaModelUtil.methods(c);
    for (final Method m : _methods) {
      {
        final Method overridden = hierarchyMethods.get(m.getName());
        if (((overridden != null) && ((!this._xMiniJavaTypeConformance.isConformant(this._xMiniJavaTypeComputer.getType(m.getTypeRef()), this._xMiniJavaTypeComputer.getType(overridden.getTypeRef()))) || (!IterableExtensions.elementsEqual(ListExtensions.<TypeRef, TypeDeclaration>map(ListExtensions.<Parameter, TypeRef>map(m.getParams(), ((Function1<Parameter, TypeRef>) (Parameter it) -> {
          return it.getTypeRef();
        })), ((Function1<TypeRef, TypeDeclaration>) (TypeRef it) -> {
          return this._xMiniJavaTypeComputer.getType(it);
        })), ListExtensions.<TypeRef, TypeDeclaration>map(ListExtensions.<Parameter, TypeRef>map(overridden.getParams(), ((Function1<Parameter, TypeRef>) (Parameter it) -> {
          return it.getTypeRef();
        })), ((Function1<TypeRef, TypeDeclaration>) (TypeRef it) -> {
          return this._xMiniJavaTypeComputer.getType(it);
        }))))))) {
          String _name = m.getName();
          String _plus = ("The method \'" + _name);
          String _plus_1 = (_plus + "\' must override a superclass method");
          this.error(_plus_1, m, 
            XminiJavaPackage.eINSTANCE.getNamedElement_Name(), XMiniJavaValidator.WRONG_METHOD_OVERRIDE);
        } else {
          AccessLevel _access = m.getAccess();
          AccessLevel _access_1 = overridden.getAccess();
          boolean _lessThan = (_access.compareTo(_access_1) < 0);
          if (_lessThan) {
            AccessLevel _access_2 = overridden.getAccess();
            String _plus_2 = ("Cannot reduce access from " + _access_2);
            String _plus_3 = (_plus_2 + " to ");
            AccessLevel _access_3 = m.getAccess();
            String _plus_4 = (_plus_3 + _access_3);
            this.error(_plus_4, m, 
              XminiJavaPackage.eINSTANCE.getMember_Access(), XMiniJavaValidator.REDUCED_ACCESSIBILITY);
          }
        }
      }
    }
  }
  
  public static boolean isAbstractOrInterface(final TypeDeclaration t) {
    if ((t instanceof org.imt.minijava.xminiJava.Class)) {
      return ((org.imt.minijava.xminiJava.Class)t).isAbstract();
    } else {
      if ((t instanceof Interface)) {
        return true;
      }
    }
    return false;
  }
  
  @Check
  public void checkMethodAbstract(final Method method) {
    if ((method.isAbstract() && (method.getBody() != null))) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("The abstract method ");
      String _name = method.getName();
      _builder.append(_name);
      _builder.append(" cannot have a body.");
      this.error(_builder.toString(), method, 
        XminiJavaPackage.eINSTANCE.getMethod_Body(), XMiniJavaValidator.ABSTRACT_METHOD_BODY);
    }
    if ((method.isAbstract() && (!XMiniJavaValidator.isAbstractOrInterface(((TypeDeclaration) method.eContainer()))))) {
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("The abstract method ");
      String _name_1 = method.getName();
      _builder_1.append(_name_1);
      _builder_1.append(" must be contained in an abstract class or in an interface.");
      this.error(_builder_1.toString(), method, XminiJavaPackage.eINSTANCE.getMethod_Abstract(), XMiniJavaValidator.ABSTRACT_METHOD_CLASS);
    }
  }
  
  @Check
  public void checkInterfaceMembers(final Interface i) {
    final Function1<Member, Boolean> _function = (Member it) -> {
      return Boolean.valueOf((it instanceof Field));
    };
    boolean _exists = IterableExtensions.<Member>exists(i.getMembers(), _function);
    if (_exists) {
      this.error("An interface cannot contain a field.", i, XminiJavaPackage.eINSTANCE.getTypeDeclaration_Members(), 
        XMiniJavaValidator.INTERFACE_MEMBERS);
    }
  }
  
  @Check
  public void checkConstructor(final Method constructor) {
    String _name = constructor.getName();
    boolean _tripleEquals = (_name == null);
    if (_tripleEquals) {
      EObject _eContainer = constructor.eContainer();
      final org.imt.minijava.xminiJava.Class parentClass = ((org.imt.minijava.xminiJava.Class) _eContainer);
      TypeRef _typeRef = constructor.getTypeRef();
      TypeDeclaration _referencedClass = ((ClassRef) _typeRef).getReferencedClass();
      boolean _tripleNotEquals = (_referencedClass != parentClass);
      if (_tripleNotEquals) {
        this.error("A constructor must be in the same class as its name.", constructor, 
          XminiJavaPackage.eINSTANCE.getTypedDeclaration_TypeRef(), XMiniJavaValidator.CONSTRUCTOR_CLASS);
      }
    }
  }
  
  @Check
  public void checkAccessibility(final FieldAccess sel) {
    final Field field = sel.getField();
    if (((field.getName() != null) && (!this._xMiniJavaAccessibility.isAccessibleFrom(field, sel)))) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("The ");
      AccessLevel _access = field.getAccess();
      _builder.append(_access);
      _builder.append(" member ");
      String _name = field.getName();
      _builder.append(_name);
      _builder.append(" is not accessible here");
      this.error(_builder.toString(), 
        XminiJavaPackage.eINSTANCE.getFieldAccess_Field(), 
        XMiniJavaValidator.MEMBER_NOT_ACCESSIBLE);
    }
  }
  
  @Check
  public void checkAccessibility(final MethodCall sel) {
    final Method method = sel.getMethod();
    if (((method.getName() != null) && (!this._xMiniJavaAccessibility.isAccessibleFrom(method, sel)))) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("The ");
      AccessLevel _access = method.getAccess();
      _builder.append(_access);
      _builder.append(" member ");
      String _name = method.getName();
      _builder.append(_name);
      _builder.append(" is not accessible here");
      this.error(_builder.toString(), 
        XminiJavaPackage.eINSTANCE.getMethodCall_Method(), 
        XMiniJavaValidator.MEMBER_NOT_ACCESSIBLE);
    }
  }
  
  @Check
  public void checkAccessibility(final NewObject n) {
    final Function1<Method, Boolean> _function = (Method it) -> {
      return Boolean.valueOf(((it.getName() == null) && (it.getParams().size() == n.getArgs().size())));
    };
    final Method constructor = IterableExtensions.<Method>findFirst(Iterables.<Method>filter(n.getType().getMembers(), Method.class), _function);
    boolean _isAccessibleFrom = this._xMiniJavaAccessibility.isAccessibleFrom(constructor, n);
    boolean _not = (!_isAccessibleFrom);
    if (_not) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("This constructor is not accessible here.");
      this.error(_builder.toString(), 
        XminiJavaPackage.eINSTANCE.getNewObject_Type(), 
        XMiniJavaValidator.MEMBER_NOT_ACCESSIBLE);
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkDuplicateClassesInFiles(final Program p) {
    final Map<QualifiedName, IEObjectDescription> externalClasses = this._xMiniJavaIndex.getVisibleExternalClassesDescriptions(p);
    EList<TypeDeclaration> _classes = p.getClasses();
    for (final TypeDeclaration c : _classes) {
      {
        final QualifiedName className = this._iQualifiedNameProvider.getFullyQualifiedName(c);
        boolean _containsKey = externalClasses.containsKey(className);
        if (_containsKey) {
          String _name = c.getName();
          String _plus = ("The type " + _name);
          String _plus_1 = (_plus + " is already defined");
          this.error(_plus_1, c, XminiJavaPackage.eINSTANCE.getNamedElement_Name(), 
            XMiniJavaValidator.DUPLICATE_CLASS);
        }
      }
    }
  }
  
  @Check
  public void checkSuper(final Super s) {
    if (((!Objects.equal(s.eContainingFeature(), XminiJavaPackage.eINSTANCE.getMethodCall_Receiver())) && 
      (!Objects.equal(s.eContainingFeature(), XminiJavaPackage.eINSTANCE.getFieldAccess_Receiver())))) {
      this.error("\'super\' can be used only as member selection receiver", null, XMiniJavaValidator.WRONG_SUPER_USAGE);
    }
  }
  
  private void checkNoDuplicateElements(final Iterable<? extends NamedElement> elements, final String desc) {
    final HashMultimap<String, NamedElement> multiMap = HashMultimap.<String, NamedElement>create();
    for (final NamedElement e : elements) {
      multiMap.put(e.getName(), e);
    }
    Set<Map.Entry<String, Collection<NamedElement>>> _entrySet = multiMap.asMap().entrySet();
    for (final Map.Entry<String, Collection<NamedElement>> entry : _entrySet) {
      {
        final Collection<NamedElement> duplicates = entry.getValue();
        int _size = duplicates.size();
        boolean _greaterThan = (_size > 1);
        if (_greaterThan) {
          for (final NamedElement d : duplicates) {
            String _name = d.getName();
            String _plus = ((("Duplicate " + desc) + " \'") + _name);
            String _plus_1 = (_plus + "\'");
            this.error(_plus_1, d, XminiJavaPackage.eINSTANCE.getNamedElement_Name(), 
              XMiniJavaValidator.DUPLICATE_ELEMENT);
          }
        }
      }
    }
  }
}
