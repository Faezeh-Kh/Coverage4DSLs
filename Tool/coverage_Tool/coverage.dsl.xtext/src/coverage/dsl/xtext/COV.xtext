// automatically generated by Xtext
grammar coverage.dsl.xtext.COV with org.eclipse.xtext.common.Terminals

import "https://coverage/DSLSpecificCoverage" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

DomainSpecificCoverage returns DomainSpecificCoverage:
	'ruleset'
	name=EString
	'{'
		'import' 'metamodel' metamodel=[ecore::EPackage|EString]
		coverageMetrics+=CoverageMetric ( "," coverageMetrics+=CoverageMetric)* 
	'}';

CoverageMetric returns CoverageMetric:
	ModelElementCoverage | BranchCoverage;
	
	
ModelElementCoverage returns ModelElementCoverage:
	'ModelElementCoverageRuleset'
	'{'
	 	contexts+=Context ( "," contexts+=Context)*
	'}';
	
BranchCoverage returns BranchCoverage:
	{BranchCoverage} 'BranchCoverageRuleset'
	'{'
	 	(contexts+=Context ( "," contexts+=Context)*)?
	'}';
	 
EString returns ecore::EString:
	STRING | ID;

Context returns Context:
	'context' metaclass=[ecore::EClass|EString]
	'{'
		(rules+=Rule ( "," rules+=Rule)*)?
	'}';

Rule returns Rule:
	Ignore | CoverageOfReferenced | CoverageByContent | LimitedIgnore | BranchSpecification;

EBoolean returns ecore::EBoolean:
	'true' | 'false';

Ignore returns Ignore:
	{Ignore} 
	'ignore' '(' ('subtypes' ignoreSubtypes=EBoolean)? ')'
		('description' description=EString)?
		('condition' condition=Condition)?;
	
LimitedIgnore returns LimitedIgnore:
	'ignoreif' type=LimitationType
		containerMetaclass+=[ecore::EClass|EString] ( "," containerMetaclass+=[ecore::EClass|EString])* 
		('description' description=EString)?
		('condition' condition=Condition)?;
	
CoverageOfReferenced returns CoverageOfReferenced:
	'covers' reference+=[ecore::EReference|EString] ("," reference+=[ecore::EReference|EString])*
		('description' description=EString)?
		('condition' condition=Condition)?;
	
CoverageByContent returns CoverageByContent:
	'covered' 'when' multiplicity=CoveredContents 
		containmentReference=[ecore::EReference|EString] 'iscovered'
		('description' description=EString)?
		('condition' condition=Condition)?;
		

BranchSpecification returns BranchSpecification:
	'has' 'branches' '{' 
		('description' description=EString)?
		('condition' condition=Condition)?
		branches += Branch (',' branches += Branch)* 
	'}';

Branch returns Branch:
	'queryBranch' OCLQuery=EString;
	
Condition returns Condition:
	OCLConstraint=EString;
	
enum CoveredContents returns CoveredContents:
	ALL = 'ALL' | ONE = 'ONE';

enum LimitationType returns LimitationType:
	containedBy = 'containedBy' | notContainedBy = 'notContainedBy';
